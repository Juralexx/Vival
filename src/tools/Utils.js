export function getImg(props) {
    return ({
        backgroundImage: `url(${props})`,
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center",
        backgroundSize: "cover"
    })
}

/**
 * Return a randam ID.
 */

export const randomID = (max) => {
    const allCapsAlpha = [..."ABCDEFGHIJKLMNOPQRSTUVWXYZ"];
    const allLowerAlpha = [..."abcdefghijklmnopqrstuvwxyz"];
    const allUniqueChars = [..."~!@#$%^&*()_+-=[]\\{}|;:,./<>?"];
    const allNumbers = [..."0123456789"];

    const baseline = [...allCapsAlpha, ...allNumbers, ...allLowerAlpha, ...allUniqueChars];

    const generator = (base, len) => {
        return [...Array(len)]
            .map(i => base[Math.random() * base.length | 0])
            .join('');
    }

    return generator(baseline, max)
}

/**
 * Return a randam 24 numbers and letters ID.
 */

export const randomNbLtID = (max) => {
    const allLowerAlpha = [..."abcdefghijklmnopqrstuvwxyz"];
    const allNumbers = [..."0123456789"];

    const baseline = [...allNumbers, ...allLowerAlpha];

    const generator = (base, len) => {
        return [...Array(len)]
            .map(i => base[Math.random() * base.length | 0])
            .join('');
    }

    return generator(baseline, max)
}

/**
 * Return a randam 24 numbers ID.
 */

export const randomNbID = (max) => {
    const allNumbers = [..."0123456789"];
    const baseline = [...allNumbers];

    const generator = (base, len) => {
        return [...Array(len)]
            .map(i => base[Math.random() * base.length | 0])
            .join('');
    }

    return generator(baseline, max)
}

/**
 * Check pseudo validity.
 */

export const onlyLettersSpacesAndDashes = (string) => {
    const regexp = new RegExp(/^[A-Za-z\s\-]+$/)
    if (regexp.test(string)) return true
    else return false
}

/**
 * Check if a string contains only letters, numbers and dashes validity.
 */

export const onlyLettersNumbersAndDashes = (string) => {
    const regexp = new RegExp(/^(\w|-)+$/)
    if (regexp.test(string)) return true
    else return false
}

/**
 * Check email validity.
 */

export const isEmailValid = (email) => {
    const regexp = new RegExp(/^[a-zA-Z0-9][\-_\.\+\!\#\$\%\&\'\*\/\=\?\^\`\{\|]{0,1}([a-zA-Z0-9][\-_\.\+\!\#\$\%\&\'\*\/\=\?\^\`\{\|]{0,1})*[a-zA-Z0-9]@[a-zA-Z0-9][-\.]{0,1}([a-zA-Z][-\.]{0,1})*[a-zA-Z0-9]\.[a-zA-Z0-9]{1,}([\.\-]{0,1}[a-zA-Z]){0,}[a-zA-Z0-9]{0,}$/i)
    if (regexp.test(email)) return true
    else return false
}

/**
 * Check theme and return choosen values.
 */

export const checkTheme = (light, dark) => {
    const theme = localStorage.getItem("theme")
    if (theme !== null && theme === "light")
        return light
    else return dark
}

/**
 * Return date formated : dd mon. YYY.
 */

export const dateParser = (num) => {
    let options = { year: "numeric", month: "short", day: "2-digit" }
    let timestamp = Date.parse(num)
    let date = new Date(timestamp).toLocaleDateString('fr-FR', options)
    return date.toString()
}

/**
 * Return date formated without year.
 */

export const dateParserWithoutYear = (num) => {
    let options = { month: "short", day: "2-digit" }
    let timestamp = Date.parse(num)
    let date = new Date(timestamp).toLocaleDateString('fr-FR', options)
    return date.toString()
}
/**
 * ISO date to navigator date input format.
 */

export const ISOtoNavFormat = (date) => {
    return date.substring(0, 10)
}

/**
 * Return hours only : hh:mm.
 */

export const getHourOnly = (date) => {
    const hours = date.getUTCHours();
    const minutes = date.getMinutes();
    return (1 + ((hours - 1))) + " h " + minutes.toString().padStart(2, "0");
}

/**
 * Map elements in array and return new dates only.
 */

export const keepNewDateOnly = (arrayToMap, setState) => {
    let array = []
    arrayToMap.map((element, key) => {
        return (
            array = [...array, { index: key, date: element.date.substring(0, 10) }]
        )
    })
    let filteredArray = []
    array.filter(item => {
        let i = filteredArray.findIndex(element => (element.date === item.date));
        if (i <= -1) { filteredArray.push(item) }
        return null;
    });
    setState(filteredArray)
}

/**
 * Return array elements if element.date is less than 24 hours ago.
 */

export const thisDay = (array) => {
    return array.filter(element => element.date.substring(0, 10) === new Date().toISOString().substring(0, 10))
}

/**
 * Return array elements if element.date is between 24 and 48 hours ago.
 */

export const lastDay = (array) => {
    return array.filter(element => element.date.substring(0, 10) === new Date(new Date().getTime() - 24 * 60 * 60 * 1000).toISOString().substring(0, 10))
}

/**
 * Return array elements between today and choosen date.
 */

export const timeBetween = (array, days) => {
    let currentDate = new Date();
    let currentDateTime = currentDate.getTime();
    let last30DaysDate = new Date(currentDate.setDate(currentDate.getDate() - days));
    let last30DaysDateTime = last30DaysDate.getTime();

    return array.filter(element => {
        const elementDateTime = new Date(element.date).getTime();
        if (elementDateTime <= currentDateTime && elementDateTime > last30DaysDateTime) {
            return true;
        }
        return false
    }).sort((a, b) => {
        return new Date(b.date) - new Date(a.date);
    });
}

/**
 * Reverse array order.
 */

export const reverseArray = (array) => {
    return array.map(array.pop, [...array])
}

/**
 * Group array values by parameter value. Return an array with nested arrays.
 */

export const groupBy = (array, parameter) => {
    let group = array.reduce((r, a) => {
        r[a[parameter]] = [...r[a.id] || [], a]
        return r
    }, {})

    return Object.values(group)
}

/**
 * Remove HTML markers
 */

export const removeHTMLMarkers = (html) => {
    let regex = /(<([^>]+)>)/ig
    return html.replace(regex, '')
}

/**
 * Converts a string to its html characters completely.
 */

export const stringToCharSet = (str) => {
    var buf = [];
    for (var i = str.length - 1; i >= 0; i--) {
        buf.unshift(['&#', str[i].charCodeAt(), ';'].join(''));
    }
    return buf.join('')
}

/**
 * Converts an html characterSet into its original character.
 */

export const charSetToChar = (str, marker) => {
    var txt = document.createElement(marker)
    txt.innerHTML = str
    return txt
}

/**
 * Check if array or object are empty.
 */

export const isEmpty = (value) => {
    return (
        value === undefined
        || value === null
        || (typeof value === "object" && Object.keys(value).length === 0)
        || (typeof value === "string" && value.trim().length === 0)
    )
}

/**
 * Check file extension
 */

export const isImage = (file) => {
    const types = ['image/jpg', 'image/jpeg', 'image/bmp', 'image/gif', 'image/png', 'image/svg+xml'];
    return types.some(el => file.type === el);
}

export const isVideo = (file) => {
    const types = ['video/mp4', 'video/webm', 'video/x-m4v', 'video/quicktime'];
    return types.some(el => file.type === el);
}

export const isFile = (file) => {
    const types = [
        '.7z',
        '.ade',
        '.mde',
        '.adp',
        '.apk',
        '.appx',
        '.appxbundle',
        '.aspx',
        '.bat',
        '.com',
        '.dll',
        '.exe',
        '.msi',
        '.cab',
        '.cmd',
        '.cpl',
        '.dmg',
        '.gz',
        '.hta',
        '.ins',
        '.ipa',
        '.iso',
        '.isp',
        '.jar',
        '.js',
        '.jse',
        '.jsp',
        '.lib',
        '.lnk',
        '.msc',
        '.msix',
        '.msixbundle',
        '.msp',
        '.mst',
        '.nsh',
        '.pif',
        '.ps1',
        '.scr',
        '.sct',
        '.wsc',
        '.shb',
        '.sys',
        '.vb',
        '.vbe',
        '.vbs',
        '.vxd',
        '.wsf',
        '.wsh',
        '.tar'
    ]
    return !types.some(el => file.name.endsWith(el))
}

export const isURL = (str) => {
    const regexp = new RegExp(/[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&//=]*)?/gi)
    if (regexp.test(str)) {
        return true
    } else return false
}

export const isURLInText = (text) => {
    const regexp = new RegExp("([a-zA-Z0-9]+://)?([a-zA-Z0-9_]+:[a-zA-Z0-9_]+@)?([a-zA-Z0-9.-]+\\.[A-Za-z]{2,4})(:[0-9]+)?([^ ])+")
    if (regexp.test(text)) {
        return true
    } else return false
}

export const returnURLsInText = (text) => {
    const regexp = new RegExp("([a-zA-Z0-9]+://)?([a-zA-Z0-9_]+:[a-zA-Z0-9_]+@)?([a-zA-Z0-9.-]+\\.[A-Za-z]{2,4})(:[0-9]+)?([^ ])+")
    let txt = text
    let arr = []
    while (regexp.test(txt)) {
        let matched = regexp.exec(txt)[0]
        console.log(matched)
        arr.push(matched)
        txt = txt.replace(matched, '')
    }
    return arr
}

/**
 * Check if array or object are empty.
 */

export const addClass = (state, classe) => {
    if (state) return classe
    else return 'not-' + classe
}

/**
 * Reduce string between 0 and choosen length.
 */

export const reduceString = (string, maxLength) => {
    if (string.length >= maxLength) {
        if (string.substring((maxLength - 1), maxLength) === " ") {
            let cleanSpaces = string.replace(string.substring((maxLength - 1), maxLength), "")
            string = cleanSpaces.substring(0, maxLength) + "..."
        }
        return string.substring(0, maxLength) + "..."
    } else return string
}

/**
 * Get diffÃ©rence between two number and add "+" before
 */

export const getDifference = (one, two) => {
    return "+" + (two - one)
}

/**
 * Convert string  in URL.
 */

export const cleanTitleMakeURL = (title, setTitle, setUrl) => {
    let newTitle = title.toLowerCase();
    newTitle = newTitle.charAt(0).toUpperCase() + newTitle.slice(1);
    newTitle = newTitle.replace(/[&#,+()$~%^.'":*?!;<>{}/\\\\]/g, " ")
    newTitle = newTitle.replace(/ +/g, " ")
    newTitle = newTitle.trim()
    setTitle(newTitle)

    function getRndInteger(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    let URL = newTitle.toLowerCase();
    URL = removeAccents(URL)
    URL = URL.replace(/ /g, "-")
    setUrl(getRndInteger(1000000000, 9999999999) + "/" + URL)
}

/**
 * Detect Enter key press.
 */

export const handleEnterKey = (event, func) => {
    if (event.key === 'Enter') {
        return func()
    } else return
}

/**
 * Basique GeoJSON structure for leaflet.
 */

export const geoJSONStructure = (props) => {
    return {
        "type": "FeatureCollection",
        "features": [
            {
                "type": "Feature",
                "properties": {},
                "geometry": {
                    "type": "Polygon",
                    "coordinates": props
                }
            }
        ]
    }
}

export const geolocToFloat = (string) => {
    let lat = string.substr(0, string.indexOf(','))
    let lon = string.substr(string.indexOf(',') + 1, string.length)
    lat = parseFloat(lat)
    lon = parseFloat(lon)
    return [lat, lon]
}

/**
 * Remove choosen characters from string
 */

export const replaceStr = (char, str) => {
    const string = str.replace(char, '')
    return string
}

/**
 * Remove all accents.
 */

let characterMap = {
    "Ã": "A",
    "Ã": "A",
    "Ã": "A",
    "Ã": "A",
    "Ã": "A",
    "Ã": "A",
    "áº¤": "A",
    "áº®": "A",
    "áº²": "A",
    "áº´": "A",
    "áº¶": "A",
    "Ã": "AE",
    "áº¦": "A",
    "áº°": "A",
    "È": "A",
    "Ã": "C",
    "á¸": "C",
    "Ã": "E",
    "Ã": "E",
    "Ã": "E",
    "Ã": "E",
    "áº¾": "E",
    "á¸": "E",
    "á»": "E",
    "á¸": "E",
    "á¸": "E",
    "È": "E",
    "Ã": "I",
    "Ã": "I",
    "Ã": "I",
    "Ã": "I",
    "á¸®": "I",
    "È": "I",
    "Ã": "D",
    "Ã": "N",
    "Ã": "O",
    "Ã": "O",
    "Ã": "O",
    "Ã": "O",
    "Ã": "O",
    "Ã": "O",
    "á»": "O",
    "á¹": "O",
    "á¹": "O",
    "È": "O",
    "Ã": "U",
    "Ã": "U",
    "Ã": "U",
    "Ã": "U",
    "Ã": "Y",
    "Ã ": "a",
    "Ã¡": "a",
    "Ã¢": "a",
    "Ã£": "a",
    "Ã¤": "a",
    "Ã¥": "a",
    "áº¥": "a",
    "áº¯": "a",
    "áº³": "a",
    "áºµ": "a",
    "áº·": "a",
    "Ã¦": "ae",
    "áº§": "a",
    "áº±": "a",
    "È": "a",
    "Ã§": "c",
    "á¸": "c",
    "Ã¨": "e",
    "Ã©": "e",
    "Ãª": "e",
    "Ã«": "e",
    "áº¿": "e",
    "á¸": "e",
    "á»": "e",
    "á¸": "e",
    "á¸": "e",
    "È": "e",
    "Ã¬": "i",
    "Ã­": "i",
    "Ã®": "i",
    "Ã¯": "i",
    "á¸¯": "i",
    "È": "i",
    "Ã°": "d",
    "Ã±": "n",
    "Ã²": "o",
    "Ã³": "o",
    "Ã´": "o",
    "Ãµ": "o",
    "Ã¶": "o",
    "Ã¸": "o",
    "á»": "o",
    "á¹": "o",
    "á¹": "o",
    "È": "o",
    "Ã¹": "u",
    "Ãº": "u",
    "Ã»": "u",
    "Ã¼": "u",
    "Ã½": "y",
    "Ã¿": "y",
    "Ä": "A",
    "Ä": "a",
    "Ä": "A",
    "Ä": "a",
    "Ä": "A",
    "Ä": "a",
    "Ä": "C",
    "Ä": "c",
    "Ä": "C",
    "Ä": "c",
    "Ä": "C",
    "Ä": "c",
    "Ä": "C",
    "Ä": "c",
    "CÌ": "C",
    "cÌ": "c",
    "Ä": "D",
    "Ä": "d",
    "Ä": "D",
    "Ä": "d",
    "Ä": "E",
    "Ä": "e",
    "Ä": "E",
    "Ä": "e",
    "Ä": "E",
    "Ä": "e",
    "Ä": "E",
    "Ä": "e",
    "Ä": "E",
    "Ä": "e",
    "Ä": "G",
    "Ç´": "G",
    "Ä": "g",
    "Çµ": "g",
    "Ä": "G",
    "Ä": "g",
    "Ä ": "G",
    "Ä¡": "g",
    "Ä¢": "G",
    "Ä£": "g",
    "Ä¤": "H",
    "Ä¥": "h",
    "Ä¦": "H",
    "Ä§": "h",
    "á¸ª": "H",
    "á¸«": "h",
    "Ä¨": "I",
    "Ä©": "i",
    "Äª": "I",
    "Ä«": "i",
    "Ä¬": "I",
    "Ä­": "i",
    "Ä®": "I",
    "Ä¯": "i",
    "Ä°": "I",
    "Ä±": "i",
    "Ä²": "IJ",
    "Ä³": "ij",
    "Ä´": "J",
    "Äµ": "j",
    "Ä¶": "K",
    "Ä·": "k",
    "á¸°": "K",
    "á¸±": "k",
    "KÌ": "K",
    "kÌ": "k",
    "Ä¹": "L",
    "Äº": "l",
    "Ä»": "L",
    "Ä¼": "l",
    "Ä½": "L",
    "Ä¾": "l",
    "Ä¿": "L",
    "Å": "l",
    "Å": "l",
    "Å": "l",
    "á¸¾": "M",
    "á¸¿": "m",
    "MÌ": "M",
    "mÌ": "m",
    "Å": "N",
    "Å": "n",
    "Å": "N",
    "Å": "n",
    "Å": "N",
    "Å": "n",
    "Å": "n",
    "NÌ": "N",
    "nÌ": "n",
    "Å": "O",
    "Å": "o",
    "Å": "O",
    "Å": "o",
    "Å": "O",
    "Å": "o",
    "Å": "OE",
    "Å": "oe",
    "PÌ": "P",
    "pÌ": "p",
    "Å": "R",
    "Å": "r",
    "Å": "R",
    "Å": "r",
    "Å": "R",
    "Å": "r",
    "RÌ": "R",
    "rÌ": "r",
    "È": "R",
    "È": "r",
    "Å": "S",
    "Å": "s",
    "Å": "S",
    "Å": "s",
    "Å": "S",
    "È": "S",
    "È": "s",
    "Å": "s",
    "Å ": "S",
    "Å¡": "s",
    "Å¢": "T",
    "Å£": "t",
    "È": "t",
    "È": "T",
    "Å¤": "T",
    "Å¥": "t",
    "Å¦": "T",
    "Å§": "t",
    "TÌ": "T",
    "tÌ": "t",
    "Å¨": "U",
    "Å©": "u",
    "Åª": "U",
    "Å«": "u",
    "Å¬": "U",
    "Å­": "u",
    "Å®": "U",
    "Å¯": "u",
    "Å°": "U",
    "Å±": "u",
    "Å²": "U",
    "Å³": "u",
    "È": "U",
    "È": "u",
    "VÌ": "V",
    "vÌ": "v",
    "Å´": "W",
    "Åµ": "w",
    "áº": "W",
    "áº": "w",
    "XÌ": "X",
    "xÌ": "x",
    "Å¶": "Y",
    "Å·": "y",
    "Å¸": "Y",
    "YÌ": "Y",
    "yÌ": "y",
    "Å¹": "Z",
    "Åº": "z",
    "Å»": "Z",
    "Å¼": "z",
    "Å½": "Z",
    "Å¾": "z",
    "Å¿": "s",
    "Æ": "f",
    "Æ ": "O",
    "Æ¡": "o",
    "Æ¯": "U",
    "Æ°": "u",
    "Ç": "A",
    "Ç": "a",
    "Ç": "I",
    "Ç": "i",
    "Ç": "O",
    "Ç": "o",
    "Ç": "U",
    "Ç": "u",
    "Ç": "U",
    "Ç": "u",
    "Ç": "U",
    "Ç": "u",
    "Ç": "U",
    "Ç": "u",
    "Ç": "U",
    "Ç": "u",
    "á»¨": "U",
    "á»©": "u",
    "á¹¸": "U",
    "á¹¹": "u",
    "Çº": "A",
    "Ç»": "a",
    "Ç¼": "AE",
    "Ç½": "ae",
    "Ç¾": "O",
    "Ç¿": "o",
    "Ã": "TH",
    "Ã¾": "th",
    "á¹": "P",
    "á¹": "p",
    "á¹¤": "S",
    "á¹¥": "s",
    "XÌ": "X",
    "xÌ": "x",
    "Ð": "Ð",
    "Ñ": "Ð³",
    "Ð": "Ð",
    "Ñ": "Ðº",
    "AÌ": "A",
    "aÌ": "a",
    "EÌ": "E",
    "eÌ": "e",
    "IÌ": "I",
    "iÌ": "i",
    "Ç¸": "N",
    "Ç¹": "n",
    "á»": "O",
    "á»": "o",
    "á¹": "O",
    "á¹": "o",
    "á»ª": "U",
    "á»«": "u",
    "áº": "W",
    "áº": "w",
    "á»²": "Y",
    "á»³": "y",
    "È": "A",
    "È": "a",
    "È": "E",
    "È": "e",
    "È": "I",
    "È": "i",
    "È": "O",
    "È": "o",
    "È": "R",
    "È": "r",
    "È": "U",
    "È": "u",
    "BÌ": "B",
    "bÌ": "b",
    "ÄÌ£": "C",
    "ÄÌ£": "c",
    "ÃÌ": "E",
    "ÃªÌ": "e",
    "FÌ": "F",
    "fÌ": "f",
    "Ç¦": "G",
    "Ç§": "g",
    "È": "H",
    "È": "h",
    "JÌ": "J",
    "Ç°": "j",
    "Ç¨": "K",
    "Ç©": "k",
    "MÌ": "M",
    "mÌ": "m",
    "PÌ": "P",
    "pÌ": "p",
    "QÌ": "Q",
    "qÌ": "q",
    "ÅÌ©": "R",
    "ÅÌ©": "r",
    "á¹¦": "S",
    "á¹§": "s",
    "VÌ": "V",
    "vÌ": "v",
    "WÌ": "W",
    "wÌ": "w",
    "XÌ": "X",
    "xÌ": "x",
    "YÌ": "Y",
    "yÌ": "y",
    "AÌ§": "A",
    "aÌ§": "a",
    "BÌ§": "B",
    "bÌ§": "b",
    "á¸": "D",
    "á¸": "d",
    "È¨": "E",
    "È©": "e",
    "ÆÌ§": "E",
    "ÉÌ§": "e",
    "á¸¨": "H",
    "á¸©": "h",
    "IÌ§": "I",
    "iÌ§": "i",
    "ÆÌ§": "I",
    "É¨Ì§": "i",
    "MÌ§": "M",
    "mÌ§": "m",
    "OÌ§": "O",
    "oÌ§": "o",
    "QÌ§": "Q",
    "qÌ§": "q",
    "UÌ§": "U",
    "uÌ§": "u",
    "XÌ§": "X",
    "xÌ§": "x",
    "ZÌ§": "Z",
    "zÌ§": "z",
};

let chars = Object.keys(characterMap).join('|')
let allAccents = new RegExp(chars, 'g')

export const removeAccents = (string) => {
    return string.replace(allAccents, (match) => {
        return characterMap[match];
    })
}